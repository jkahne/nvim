snippet frozen
	# frozen_string_literal: true
snippet #!
	#!/usr/bin/env ruby
snippet case
	case ${1:object}
	when $2
		${0}
	end
snippet switch
	case ${1:object}
	when $2
		${0}
	end
snippet when
	when $1
		${0:${VISUAL}}
snippet def
	def ${1:method_name}
		${0}
	end
snippet defm
	def ${1:method}
		@$1 ||= ${0}
	end
snippet defs
	def self.${1:class_method_name}
		${0}
	end
snippet if
	if $1
		${0:${VISUAL}}
	end
snippet ife
	if $1
		${2:${VISUAL}}
	else
		${0}
	end
snippet eif
	elsif $1
		${0:${VISUAL}}
snippet ifee
	if $1
		$2
	elsif $3
		$4
	else
		$0
	end
# def initialize
snippet definit
	def initialize(${1:args})
		${0}
	end
snippet tim
	times { |${1:n}| ${0} }
snippet e
	each { |${1:e}| ${0} }
snippet ed
	each do |${1:e}|
		${0}
	end
snippet ewo
	each_with_object(${1:init}) { |${2:e}, ${3:acc}| ${0} }
snippet ewod
	each_with_object(${1:init}) do |${2:e}, ${3:acc}|
		${0}
	end
snippet red
	reduce(${1:init}) { |${2:mem}, ${3:var}| ${0} }
snippet redd
	reduce(${1:init}) do |${2:mem}, ${3:var}|
		${0}
	end
snippet map
	map { |${1:e}| ${0} }
snippet mapd
	map do |${1:e}|
		${0}
	end
snippet sor
	sort { |a, b| ${0} }
snippet sorb
	sort_by { |${1:e}| ${0} }
snippet ran
	sort_by { rand }
snippet all
	all? { |${1:e}| ${0} }
snippet any
	any? { |${1:e}| ${0} }
snippet col
	collect { |${1:e}| ${0} }
snippet cold
	collect do |${1:e}|
		${0}
	end
snippet det
	detect { |${1:e}| ${0} }
snippet detd
	detect do |${1:e}|
		${0}
	end
snippet fin
	find { |${1:e}| ${0} }
snippet find
	find do |${1:e}|
		${0}
	end
snippet rej
	reject { |${1:e}| ${0} }
snippet rejd
	reject do |${1:e}|
		${0}
	end
snippet sel
	select { |${1:e}| ${0} }
snippet seld
	select do |${1:e}|
		${0}
	end

# Benchmark.bmbm do .. end
snippet bm-
	TESTS = ${1:10_000}
	Benchmark.bmbm do |results|
		${0}
	end


snippet b
	{ |${1:var}| ${0} }


snippet break
	binding.break

snippet strf
	strftime('${1:%Y-%m-%d %H:%M:%S %z}')${0}




snippet desc
	describe '${1:#method}' do
		${0:pending 'Not implemented'}
	end
snippet bef
	before :${1:each} do
		${0}
	end
snippet aft
	after :${1:each} do
		${0}
	end
snippet let
	let(:${1:object}) { ${0} }
snippet let!
	let!(:${1:object}) { ${0} }



snippet defcreate
	def create
		@${1:model_class_name} = ${2:ModelClassName}.new($1_params)

		respond_to do |format|
			if @$1.save
				flash[:notice] = '$2 was successfully created.'
				format.html { redirect_to(@$1) }
				format.json  { render json: @$1, status: :created, location: @$1 }
			else
				format.html { render action: 'new' }
				format.json  { render json: @$1.errors, status: :unprocessable_entity }
			end
		end
	end
snippet defdestroy
	def destroy
		@${1:model_class_name} = ${2:ModelClassName}.find(params[:id])
		@$1.destroy

		respond_to do |format|
			format.html { redirect_to($1s_url) }
			format.json  { head :ok }
		end
	end
snippet defedit
	def edit
		@${1:model_class_name} = ${0:ModelClassName}.find(params[:id])
	end
snippet defindex
	def index
		@${1:model_class_name} = ${2:ModelClassName}.all

		respond_to do |format|
			format.html # index.html.erb
			format.json  { render json: @$1s }
		end
	end
snippet defnew
	def new
		@${1:model_class_name} = ${2:ModelClassName}.new

		respond_to do |format|
			format.html # new.html.erb
			format.json  { render json: @$1 }
		end
	end
snippet defshow
	def show
		@${1:model_class_name} = ${2:ModelClassName}.find(params[:id])

		respond_to do |format|
			format.html # show.html.erb
			format.json  { render json: @$1 }
		end
	end
snippet defupdate
	def update
		@${1:model_class_name} = ${2:ModelClassName}.find(params[:id])

		respond_to do |format|
			if @$1.update($1_params)
				flash[:notice] = '$2 was successfully updated.'
				format.html { redirect_to(@$1) }
				format.json  { head :ok }
			else
				format.html { render action: 'edit' }
				format.json  { render json: @$1.errors, status: :unprocessable_entity }
			end
		end
	end
snippet log
	Rails.logger.${1:debug} ${0}
snippet log2
	RAILS_DEFAULT_LOGGER.${1:debug} ${0}
snippet logd
	logger.debug { '${1:message}' }
snippet loge
	logger.error { '${1:message}' }
snippet logf
	logger.fatal { '${1:message}' }
snippet logi
	logger.info { '${1:message}' }
snippet logw
	logger.warn { '${1:message}' }


snippet mp
	map(&:${0:id})
snippet pa
	params[:${1:id}]
snippet sc
	scope :${1:name}, -> { where(${2:field}: ${0:value}) }
snippet sl
	scope :${1:name}, lambda do |${2:value}|
		where('${3:field = ?}', ${0:value})
	end
snippet sha1
	Digest::SHA1.hexdigest(${0:string})
snippet va validates_associated
	validates_associated :${0:attribute}
snippet va validates .., acceptance: true
	validates :${0:terms}, acceptance: true
snippet vc
	validates :${0:attribute}, confirmation: true
snippet ve
	validates :${1:attribute}, exclusion: { in: ${0:%w( mov avi )} }
snippet vf
	validates :${1:attribute}, format: { with: /${0:regex}/ }
snippet vi
	validates :${1:attribute}, inclusion: { in: %w(${0: mov avi }) }
snippet vl
	validates :${1:attribute}, length: { in: ${2:3}..${0:20} }
snippet vn
	validates :${0:attribute}, numericality: true
snippet vp
	validates :${0:attribute}, presence: true
snippet vu
	validates :${0:attribute}, uniqueness: true
snippet format
	format.${1:js|xml|html} { ${0} }
snippet wc
	where(${1:'conditions'}${0:, bind_var})
snippet wf
	where(${1:field}: ${0:value})
snippet whe
	where(${1:field}: ${0:value})
































